<!DOCTYPE html>
<html lang="en">
<head>
  <title>WaveFile Gem</title>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <link href='http://fonts.googleapis.com/css?family=Lato:100,300,400' rel='stylesheet' type='text/css'>
  <link href='http://fonts.googleapis.com/css?family=Playfair+Display:400italic' rel='stylesheet' type='text/css'>
  <link rel="stylesheet" type="text/css" href="http://fonts.googleapis.com/css?family=PT+Mono">
  <link rel="stylesheet" type="text/css" href="wavefile.css">
</head>
<body>
<div id="header">
  <div id="header-inner">
    <h1><a href="http://wavefilegem.com/">WaveFile Gem</a></h1>
    <ul id="navigation">
      <li><a href="getting_started.html">Getting Started</a></li>
      <li class="last"><a href="documentation.html">Documentation</a></li>
    </ul>
  </div>
</div>
<div class="section">
  <h2>First Steps</h2>
  <p>First, <a href="http://wavefilegem.com#installation">install the WaveFile gem</a>.</p>
  <p>Next, if you&rsquo;re new to audio programming, you might want to read up on some of the basics of digital audio first. Check out <a href="https://www.joelstrait.com/digital_audio_primer/">this blog post</a> for an introduction.</p></p>
</div>
<div class="section bg-white">
  <h2>Basic Concepts</h2>
  <p>The WaveFile gem lets you both read and write wave files. Reading is done using the <code>Reader</code> class, and writing is done using the <code>Writer</code> class.</p>
  <p>The <code>Buffer</code> class represents a collection of samples in a given sample format (e.g. stereo 16-bit PCM samples at a 44,100Hz sample rate). When samples are read using <code>Reader</code> they are returned in <code>Buffer</code> instances. Samples to be written are given to <code>Writer</code> wrapped in <code>Buffer</code> instances as well.</p>
  <p>A <code>Buffer</code> consists of two parts: an array of samples, and a <code>Format</code> instance that describes the sample format (since it might not be possible to determine just by looking at the raw samples). For example, the sample array in a <code>Buffer</code> read out of a mono 8-bit PCM file (in which each sample is an integer between 0 and 255) might look like this:</p>
  <pre><code>[45, 192, 13, 231, 201, 101, 15, ...etc...]</code></pre>
  <p>When there is more than one channel, each sample frame will be represent by a sub array. For example, a set of stereo floating point samples (in which each sample is between -1.0 and 1.0) might look like this:</p>
  <pre><code>[[-0.2, 0.4], [0.3, 0.9], [-0.4, -0.8], [0.9, -0.2], [-0.3, 0.4], ...etc...]</code></pre>
  <p>When writing a program that creates sound, you would generate an array like this with the sample data, then wrap it in a <code>Buffer</code>, and then use <code>Writer</code> to write the samples in the <code>Buffer</code> to disk.</p>
  <p>A <code>Buffer</code> has the ability to convert its samples to any other format this gem supports. This means you can read samples from a file in whatever format you like, regardless of the actual sample format in the file (e.g. read a file with 8-bit samples and get 16-bit samples back). You can also do the same with <code>Writer</code> &ndash; for example, rather than remember the sample range of a PCM format (was it 32,767? or 32,768?) you can just generate floating point samples between -1.0 and 1.0, and transparently write them out as PCM samples.</p>
</div>
<div class="section">
  <h2>Creating a New Wave File</h2>
  <p>Let&rsquo;s write a simple tone to a wave file. A <a href="http://en.wikipedia.org/wiki/Square_wave">square wave</a> is about the simplest way to create a sound, so let&rsquo;s do that. A square wave consists a some repeated samples, followed by the same number of repeated samples at the opposite amplitude. For example:</p>
  <pre><code>[0.3, 0.3, 0.3, 0.3, -0.3, -0.3, -0.3, -0.3,  ...and repeated...]</code></pre>
  <p>We&rsquo;ll write some code to generate these samples, wrap them in a <code>Buffer</code>, and then write this <code>Buffer</code> to a file using <code>Writer</code>.</p>
  <p>The samples we&rsquo;ll generate will be in float format, which means they should be between -1.0 and 1.0. The larger each sample value, the higher the amplitude (i.e. how loud it is). The faster that we alternate between the positive and negative samples, the higher the frequency of the tone (i.e., <code>[0.2, 0.2, -0.2, -0.2]</code> will have a higher pitch than <code>[0.2, 0.2, 0.2, -0.2, -0.2, -0.2]</code>). (This is a really simplified explanation of things).</p>
  <p>50 positive samples followed by 50 negative samples will produce the same pitch as middle A on a piano when the sample rate is 44,100Hz. Let&rsquo;s use that and generate our sample array:</p>
  <pre><code>AMPLITUDE = 0.3
one_square_cycle = ([AMPLITUDE] * 50) + ([-AMPLITUDE] * 50)</code></pre>
  <p>Next, let&rsquo;s wrap the samples in a <code>Buffer</code>:</p>
  <pre><code>buffer = Buffer.new(one_square_cycle, Format.new(:mono, :float, 44100))</code></pre>
  <p>Notice that we used the <code>Format</code> class to identify the sample format. The <code>Format</code> constructor takes 3 arguments: the number of channels, the format of each sample, and the sample rate. You&rsquo;re on the honor system to use the correct format here, weird stuff could happen if you use the wrong format.</p>
  <p>Now let&rsquo;s write the buffer to a file called <code>"square.wav"</code> in the current working directory:</p>
  <pre><code>Writer.new("square.wav", Format.new(:mono, :pcm_16, 44100)) do |writer|
  writer.write(buffer)
end</code></pre>
  <p>Notice that we gave the <code>Writer</code> a <code>Format</code> as well. This determines which format samples will be written as. Notice that the sample format (<code>:pcm_16</code>) is different from the <code>Buffer</code> we created &ndash; the gem will handle the necessary translation behind the scenes.</p>
  <p>All of the code to write the samples is done inside a block. When the block exits the file will automatically be closed. (If you want more manually control over when the file is closed you can do that as well by not passing a block and manually calling <code>close())</code>.</p>
  <p>Here&rsquo;s the full program so far:</p>
  <pre><code>require 'wavefile'
include WaveFile    # So we don't have to prefix all classes with 'WaveFile::'

AMPLITUDE = 0.3
one_square_cycle = ([AMPLITUDE] * 50) + ([-AMPLITUDE] * 50)

buffer = Buffer.new(one_square_cycle, Format.new(:mono, :float, 44100))

Writer.new("square.wav", Format.new(:mono, :pcm_16, 44100)) do |writer|
  writer.write(buffer)
end</code></pre>
  <p>When you run this program it should create a file called <code>"square.wav"</code> in the current working directory. If you play this file (for example on a Mac using <code>afplay square.wav</code> from the command line) it should sound like this:</p>
  <audio controls>
    <source src="media/square_too_short.wav" type="audio/wav">
  </audio>
  <p>...which... doesn&rsquo;t sound like anything! The reason is that we didn&rsquo;t generate enough samples. At the sample rate we&rsquo;re using, 44,100Hz, you&rsquo;ll need 44,100 samples for 1 second of sound. We only generated 100 samples, or about 1/441th of a second. No problem, we can easily fix this by repeating our cycle more times:</p>
  <pre><code>CYCLE_COUNT = 441   # 441 x 100 samples == 44,100 samples, or 1 second of sound

Writer.new("square.wav", Format.new(:mono, :pcm_16, 44100)) do |writer|
  CYCLE_COUNT.times { writer.write(buffer) }
end</code></pre>
  <p>Now when you re-run the program and play <code>"square.wav"</code> it should sound like this.</p>
  <audio controls>
    <source src="media/square.wav" type="audio/wav">
  </audio>
  <p>You are well on your way to writing an epic <a href="http://en.wikipedia.org/wiki/Nintendo_Entertainment_System">NES</a> soundtrack!</p>
  <p>Here&rsquo;s the full program:</p>
  <pre><code>require 'wavefile'
include WaveFile    # So we don't have to prefix all classes with 'WaveFile::'

AMPLITUDE = 0.3
CYCLE_COUNT = 441   # 441 x 100 samples == 44,100 samples, or 1 second of sound
one_square_cycle = ([AMPLITUDE] * 50) + ([-AMPLITUDE] * 50)

buffer = Buffer.new(one_square_cycle, Format.new(:mono, :float, 44100))

Writer.new("square.wav", Format.new(:mono, :pcm_16, 44100)) do |writer|
  CYCLE_COUNT.times { writer.write(buffer) }
end</code></pre>
</div>
<div class="section bg-white">
  <h2>Reading a Wave File</h2>
  <p>Let&rsquo;s now read the file we just wrote. We can use the <code>Reader</code> class for that.</p>
  <pre><code>require 'wavefile'
include WaveFile    # So we don't have to prefix all classes with 'WaveFile::'

Reader.new("square.wav").each_buffer do |buffer|
  puts "Buffer number of channels:   #{buffer.channels}"
  puts "Buffer bits per sample:      #{buffer.bits_per_sample}"
  puts "Number of samples in buffer: #{buffer.samples.length}"
  puts "First 10 samples in buffer:  #{buffer.samples[0...10].inspect}"
  puts "--------------------------------------------------------------"
end</code></pre>
  <p>After constructing the <code>Reader</code> we call the <code>each_buffer</code> method. This method is useful when you want to read an entire file. It reads successive buffers of a given size, and passes each to the given block. When all buffers have been read, the file is automatically closed. (You can also manually control what to read and when to close the file, see the <a href="examples.html">examples</a> page for more info).</p>
  <p>When you run the program, it should print out repeated output similar to the following:</p>
  <pre><code>Buffer number of channels:   1
Buffer bits per sample:      16
Number of samples in buffer: 4096
First 10 samples in buffer:  [9830, 9830, 9830, 9830, 9830, 9830, 9830, 9830, 9830, 9830]</code></pre>
  <p>Notice how these samples are integers, rather than the floats that we generated in the last section. This is because when we saved that file, we indicated (via the <code>Format</code> instance we gave) that the samples should be written as 16-bit PCM samples instead of floating point.</p>
  <p>Also notice that we only read 4,096 samples at a time, instead of trying to the read the whole file. It&rsquo;s a generally a good idea to read a larger number of smaller buffers, rather than one giant buffer. For this file it probably doesn&rsquo;t matter, but longer files can have millions of samples, and Ruby can have trouble with arrays this large.</p>
  <p>OK, well that&rsquo;s cool, but let&rsquo;s say we want to read this file so we can do some transformation on it, and it will be easier to work with if the samples are in floating point format, and are stereo (since we want to combine it with some other files that are stereo). No problem, when constructing the <code>Reader</code> we just need to pass a <code>Format</code> instance that describes our desired sample format.</p>
  <pre><code>require 'wavefile'
include WaveFile    # So we don't have to prefix all classes with 'WaveFile::'

reader = Reader.new("square.wav", <span class="highlight">Format.new(:stereo, :float, 44100)</span>)
reader.each_buffer do |buffer|
  puts "Buffer number of channels:   #{buffer.channels}"
  puts "Buffer bits per sample:      #{buffer.bits_per_sample}"
  puts "Number of samples in buffer: #{buffer.samples.length}"
  puts "First 10 samples in buffer:  #{buffer.samples[0...10].inspect}"
  puts "--------------------------------------------------------------"
end</code></pre>
  <p>Now when you run this program, the output should look like this:</p>
  <pre><code>Buffer number of channels:   2
Buffer bits per sample:      32
Number of samples in buffer: 4096
First 10 samples in buffer:  [[0.29998779296875, 0.29998779296875],
                              [0.29998779296875, 0.29998779296875],
                              [0.29998779296875, 0.29998779296875],
                              [0.29998779296875, 0.29998779296875],
                              [0.29998779296875, 0.29998779296875],
                              [0.29998779296875, 0.29998779296875],
                              [0.29998779296875, 0.29998779296875],
                              [0.29998779296875, 0.29998779296875],
                              [0.29998779296875, 0.29998779296875],
                              [0.29998779296875, 0.29998779296875]]</code></pre>
</div>
<div class="section">
  <h2>Next Steps</h2>
  <p>Head over to the <a href="documentation.html">Documentation</a> page where you can see more <a href="examples.html">code examples</a>, read full <a href="doc/index.html">API documentation</a>, and get the low down on <a href="how_wave_files_work.html">how the Wave file format works</a> behind the scenes.</p>
</div>
<div class="footer">
  <p>View the source on <a href="https://github.com/jstrait/wavefile/">GitHub</a>.</p>
  <p>Copyright &copy; <a href="https://www.joelstrait.com">Joel Strait</a> 2009-18.</p>
</div>
</body>
</html>
