<!DOCTYPE html>
<html lang="en">
<head>
  <title>WaveFile Gem</title>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <link href='http://fonts.googleapis.com/css?family=Lato:100,300,400' rel='stylesheet' type='text/css'>
  <link href='http://fonts.googleapis.com/css?family=Playfair+Display:400italic' rel='stylesheet' type='text/css'>
  <link rel="stylesheet" type="text/css" href="http://fonts.googleapis.com/css?family=PT+Mono">
  <link rel="stylesheet" type="text/css" href="wavefile.css">
</head>
<body>
<div id="header">
  <h1><a href="http://wavefilegem.com/">WaveFile Gem</a></h1>
  <ul id="navigation">
    <li><a href="getting_started.html">Getting Started</a></li>
    <li><a href="documentation.html">Documentation</a></li>
  </ul>
</div>

<div class="section">
  <h2>Reading a Wave File With a Block</h2>

  <p>The example below shows the preferred way of reading an entire wave file:</p>

  <pre><code>require 'wavefile'
include WaveFile 

SAMPLE_FRAMES_PER_BUFFER = 4096

Reader.new("my_file.wav").each_buffer(SAMPLE_FRAMES_PER_BUFFER) do |buffer|
  puts "Read #{buffer.samples.length} samples."
end</code></pre>

  <p>First construct a <code>Reader</code> object, then call <code>each_buffer()</code> on it. Successive sample buffers will be read from the file and passed to the given block, until all sample data in the file has been read. Finally, the <code>Reader</code> will automatically be closed. (Note that this is essentially the same as how <code>IO.open</code> works if you pass it a block).</p>

  <p>Note that when calling <code>each_buffer()</code> (and <code>read()</code>), the number you pass indicates the number of samples to read for <strong><em>each channel</em></strong>. That is, if you call <code>each_buffer(1024)</code> on a stereo/16-bit file, then the returned buffer will contain 1024 samples for the left channel, and 1024 samples for the right channel.</p>
</div>

<div class="section bg-white">
  <h2>Reading a Wave File (Manual File Closing Edition)</h2>

  <p>Alternately, you can manually call <code>read()</code> to control exactly how much of the file to read. When doing this, make sure to close the <code>Reader</code> when you're done.</p>

  <pre><code>require 'wavefile'
include WaveFile

SAMPLES_PER_BUFFER = 4096

reader = Reader.new("my_file.wav")
begin
  while true do
    buffer = reader.read(SAMPLES_PER_BUFFER)
    puts "Read #{buffer.samples.length} samples."
  end
rescue EOFError
  reader.close
end</code></pre>
</div>

<div class="section">
  <h2>Reading a Wave File Into an Arbitrary Format</h2>

  <p>It's easy to read sample data out of a file in whatever format you need, regardless of what format is used inside the file. For example, suppose that <code>my_file.wav</code> is stereo/16-bit, but you need mono normalized floating point samples. No problem, as shown below.</p>

  <pre><code>require 'wavefile'
include WaveFile

SAMPLES_PER_BUFFER = 4096

# Samples will be read as monophonic floating point,
# regardless of the actual sample format on disk
format = Format.new(:mono, :float, 44100)
reader = Reader.new("my_file.wav", format).each_buffer(SAMPLES_PER_BUFFER) do |buffer|
  puts "Read #{buffer.samples.length} samples."
end</code></pre>
</div>

<div class="section bg-white">
  <h2>Getting Metadata About a Wave File</h2>

  <pre><code>require 'wavefile'
include WaveFile

info = Reader.info("my_file.wav")
puts "  Audio Format:        #{info.audio_format}"
puts "  Channels:            #{info.channels}"
puts "  Bits per sample:     #{info.bits_per_sample}"
puts "  Samples per second:  #{info.sample_rate}"
puts "  Bytes per second:    #{info.byte_rate}"
puts "  Block align:         #{info.block_align}"
puts "  Sample frame count:  #{info.sample_frame_count}"

duration = info.duration
formatted_duration = duration.hours.to_s.rjust(2, "0") &lt;&lt; ":" &lt;&lt;
                     duration.minutes.to_s.rjust(2, "0") &lt;&lt; ":" &lt;&lt;
                     duration.seconds.to_s.rjust(2, "0") &lt;&lt; ":" &lt;&lt;
                     duration.milliseconds.to_s.rjust(3, "0")
puts "  Play time:           #{formatted_duration}"</code></pre>
</div>

<div class="section">
  <h2>Writing a Wave File With A Block</h2>

  <p>The <code>Writer</code> object is used to write data to a wave file. When constructing the <code>Writer</code>, one can pass a block inside which the writing will occur. When the block exits the file will automatically be closed. The example below shows how to write a basic square wave to a file.</p>

  <pre><code>require 'wavefile'
include WaveFile

# Write a 440Hz square wave beep
cycle = ([0.5] * 50) + ([-0.5] * 50)
buffer = Buffer.new(cycle, Format.new(:mono, :float, 44100))
Writer.new("my_file.wav", Format.new(:mono, :pcm_16, 44100)) do |writer|
  100.times { writer.write(buffer) }
end</code></pre>
</div>

<div class="section bg-white">
  <h2>Writing a Wave File (Manual File Close Edition)</h2>

  <p>Alternately, one can manually control when to close the file, as shown below. Note that a file won't be valid for playback until it is closed. This is because some data required for playback (such as the total number of samples) isn't written to the file until it is closed.</p>

  <pre><code>require 'wavefile'
include WaveFile

writer = Writer.new("my_file.wav", Format.new(:mono, :pcm_16, 44100))

# Write a 440Hz square wave beep
cycle = ([0.5] * 50) + ([-0.5] * 50)
buffer = Buffer.new(cycle, Format.new(:mono, :float, 44100))
100.times do
  writer.write(buffer)
end

writer.close</code></pre>
</div>

<div class="section">
  <h2>Copying a Wave File to Different Format</h2>

  <p>In this example, the sample data in the file <code>original.wav</code> will be written to <code>copy.wav</code> as stereo/16-bit with a 44,100Hz sample rate, regardless of what format the sample data in <code>original.wav</code> is stored in.</p>

  <p>This example also shows that you can also pass a block to <code>Writer.new()</code>, and the <code>Writer</code> will automatically be closed when the block exits.</p>

  <pre><code>require 'wavefile'
include WaveFile

SAMPLES_PER_BUFFER = 4096

Writer.new("copy.wav", Format.new(:stereo, :pcm_16, 44100) do |writer|
  Reader.new("original.wav").each_buffer(SAMPLES_PER_BUFFER) do |buffer|
    writer.write(buffer)
  end
end</code></pre>
</div>

<div class="section bg-white">
  <h2>Appending Wave Files</h2>

  <p>This example will take 3 Wave files, and write them to a single file containing each input file played one after another. Note that the individual files can be in different formats.</p>

  <pre><code>require 'wavefile'
include WaveFile

FILES_TO_APPEND = ["file1.wav", "file2.wav", "file3.wav"]
SAMPLES_PER_BUFFER = 4096

Writer.new("append.wav", Format.new(:stereo, :pcm_16, 44100) do |writer|
  FILES_TO_APPEND.each do |file_name|
    Reader.new(file_name).each_buffer(SAMPLES_PER_BUFFER) do |buffer|
      writer.write(buffer)
    end
  end
end</code></pre>
</div>
<div class="footer">
  <p>View the source on <a href="https://github.com/jstrait/wavefile/">GitHub</a>.</p>
  <p>Copyright &copy; <a href="http://www.joelstrait.com">Joel Strait</a> 2009-13.</p>
</div>
</body>
</html>
