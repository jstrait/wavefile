<!DOCTYPE html>
<html lang="en">
<head>
  <title>WaveFile Gem</title>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <link href='http://fonts.googleapis.com/css?family=Lato:100,300,400' rel='stylesheet' type='text/css'>
  <link href='http://fonts.googleapis.com/css?family=Playfair+Display:400italic' rel='stylesheet' type='text/css'>
  <link rel="stylesheet" type="text/css" href="http://fonts.googleapis.com/css?family=PT+Mono">
  <link rel="stylesheet" type="text/css" href="wavefile.css">
</head>
<body>
<div id="header">
  <div id="header-inner">
    <h1><a href="http://wavefilegem.com/">WaveFile Gem</a></h1>
    <ul id="navigation">
      <li><a href="getting_started.html">Getting Started</a></li>
      <li class="last"><a href="documentation.html">Documentation</a></li>
    </ul>
  </div>
</div>

<div class="section">
  <h2>Reading Entire Wave File With a Block</h2>

  <p>This is a simple way to read an entire wave file:</p>

  <pre><code>require 'wavefile'
include WaveFile

Reader.new("my_file.wav").each_buffer do |buffer|
  puts "Read #{buffer.samples.length} sample frames."
end</code></pre>

  <p>First construct a <code>Reader</code> object, then call <code>each_buffer()</code> on it. Successive sample buffers will be read from the file and passed to the given block, until all sample data in the file has been read. Finally, the <code>Reader</code> will automatically be closed. (Note that this is essentially the same as how <code>IO.open</code> works if you pass it a block).</p>

  <p><strong>Note:</strong> When calling <code>each_buffer()</code> (and <code>read()</code>), the number you pass indicates the number of samples to read for <em>each channel</em>. That is, if you call <code>each_buffer(1024)</code> on a stereo/16-bit file, then the returned buffer will contain 1024 samples for the left channel, and 1024 samples for the right channel.</p>
</div>

<div class="section bg-white">
  <h2>Reading Wave File Manually</h2>

  <p>Alternately, you can manually call <code>read()</code> to control exactly how much of the file to read. When doing this, make sure to close the <code>Reader</code> when you&rsquo;re done.</p>

  <pre><code>require 'wavefile'
include WaveFile

SAMPLES_PER_BUFFER = 4096

reader = Reader.new("my_file.wav")
begin
  while reader.current_sample_frame < reader.total_sample_frames do
    buffer = reader.read(SAMPLES_PER_BUFFER)
    puts "Read #{buffer.samples.length} sample frames."
  end
rescue EOFError
  puts "Unexpected EOFError before reading all sample frames"
ensure
  reader.close
end</code></pre>
</div>

<div class="section">
  <h2>Reading a Wave File Into an Arbitrary Format</h2>

  <p>It&rsquo;s easy to read sample data out of a file in whatever format you need, regardless of what format is used inside the file. For example, suppose that <code>my_file.wav</code> is stereo/16-bit, but you need mono normalized floating point samples. No problem, as shown below.</p>

  <pre><code>require 'wavefile'
include WaveFile

# Samples will be read as monophonic floating point,
# regardless of the actual sample format on disk
format = Format.new(:mono, :float, 44100)
reader = Reader.new("my_file.wav", format).each_buffer do |buffer|
  puts "Read #{buffer.samples.length} sample frames."
end</code></pre>
  <p><strong>Note:</strong> Sample data will not be re-sampled to match the target sample rate. For example, if reading data out of a file with 44,100Hz sample rate using a target <code>Format</code> with a 22,050Hz sample rate, the samples will not be re-converted to a 22,050Hz sample rate. This means the audio will sound pitch shifted unless the two sample rates are the same.</p>
</div>

<div class="section bg-white">
  <h2>Getting Metadata About a Wave File</h2>

  <pre><code>require 'wavefile'
include WaveFile

file_name = ARGV[0]
puts "Metadata for #{file_name}:"

begin
  reader = Reader.new(file_name)

  puts "  Readable by this gem?  #{reader.readable_format? ? 'Yes' : 'No'}"
  puts "  Audio Format:          #{reader.native_format.audio_format}"
  puts "  Channels:              #{reader.native_format.channels}"
  puts "  Bits per sample:       #{reader.native_format.bits_per_sample}"
  puts "  Samples per second:    #{reader.native_format.sample_rate}"
  puts "  Bytes per second:      #{reader.native_format.byte_rate}"
  puts "  Block align:           #{reader.native_format.block_align}"
  puts "  Sample frame count:    #{reader.total_sample_frames}"

  duration = reader.total_duration
  formatted_duration = duration.hours.to_s.rjust(2, "0") << ":" <<
                       duration.minutes.to_s.rjust(2, "0") << ":" <<
                       duration.seconds.to_s.rjust(2, "0") << ":" <<
                       duration.milliseconds.to_s.rjust(3, "0")
  puts "  Play time:             #{formatted_duration}"
rescue InvalidFormatError
  puts "  Not a valid Wave file!"
end</code></pre>
</div>

<div class="section">
  <h2>Writing a Wave File With A Block</h2>

  <p>The <code>Writer</code> object is used to write data to a wave file. When constructing the <code>Writer</code>, one can pass a block inside which the writing will occur. When the block exits the file will automatically be closed. The example below shows how to write a basic square wave to a file.</p>

  <pre><code>require 'wavefile'
include WaveFile

# Write a 440Hz square wave beep
cycle = ([0.5] * 50) + ([-0.5] * 50)
buffer = Buffer.new(cycle, Format.new(:mono, :float, 44100))
Writer.new("my_file.wav", Format.new(:mono, :pcm_16, 44100)) do |writer|
  100.times { writer.write(buffer) }
end</code></pre>
  <p>For more info on how to create simple sounds with Ruby, check out <a href="https://www.joelstrait.com/nanosynth_create_sound_with_ruby/">NanoSynth</a>.</p>
</div>

<div class="section bg-white">
  <h2>Writing a Wave File (Manual File Close Edition)</h2>

  <p>Alternately, one can manually control when to close the file, as shown below. Note that a file won&rsquo;t be valid for playback until it is closed. This is because some data required for playback (such as the total number of samples) isn&rsquo;t written to the file until it is closed.</p>

  <pre><code>require 'wavefile'
include WaveFile

writer = Writer.new("my_file.wav", Format.new(:mono, :pcm_16, 44100))

# Write a 440Hz square wave beep
cycle = ([0.5] * 50) + ([-0.5] * 50)
buffer = Buffer.new(cycle, Format.new(:mono, :float, 44100))
100.times do
  writer.write(buffer)
end

# The Wave file isn't in a valid state until this is called
writer.close</code></pre>
</div>

<div class="section">
  <h2>Copying a Wave File to Different Format</h2>

  <p>In this example, the sample data in the file <code>original.wav</code> will be written to <code>copy.wav</code> as stereo/16-bit with a 44,100Hz sample rate, regardless of what format the sample data in <code>original.wav</code> is stored in.</p>

  <p>This example also shows that you can also pass a block to <code>Writer.new()</code>, and the <code>Writer</code> will automatically be closed when the block exits.</p>

  <pre><code>require 'wavefile'
include WaveFile

Writer.new("copy.wav", Format.new(:stereo, :pcm_16, 44100)) do |writer|
  Reader.new("original.wav").each_buffer do |buffer|
    writer.write(buffer)
  end
end</code></pre>
</div>

<div class="section bg-white">
  <h2>Appending Wave Files</h2>

  <p>This example will take 3 Wave files, and write them to a single file containing each input file played one after another. Note that the individual files can be in different formats. They will all be converted to the output file&rsquo;s format.</p>

  <pre><code>require 'wavefile'
include WaveFile

FILES_TO_APPEND = ["file1.wav", "file2.wav", "file3.wav"]

Writer.new("append.wav", Format.new(:stereo, :pcm_16, 44100)) do |writer|
  FILES_TO_APPEND.each do |file_name|
    Reader.new(file_name).each_buffer do |buffer|
      writer.write(buffer)
    end
  end
end</code></pre>
</div>
<div class="footer">
  <p>View the source on <a href="https://github.com/jstrait/wavefile/">GitHub</a>.</p>
  <p>Copyright &copy; <a href="https://www.joelstrait.com">Joel Strait</a> 2009-18.</p>
</div>
</body>
</html>
