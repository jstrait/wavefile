---
layout: default
---
<div class="section">
  <h2>Reading Entire Wave File With a Block</h2>

  <p>This is a simple way to read an entire wave file:</p>

  {% highlight ruby %}require "wavefile"
include WaveFile

Reader.new("my_file.wav").each_buffer do |buffer|
  puts "Read #{buffer.samples.length} sample frames."
end{% endhighlight %}

  <p>First construct a <code>Reader</code> object, then call <code>each_buffer()</code> on it. Successive sample buffers will be read from the file and passed to the given block, until all sample data in the file has been read. Finally, the <code>Reader</code> will automatically be closed. (Note that this is essentially the same as how <code>IO.open</code> works if you pass it a block).</p>
</div>

<div class="section bg-white">
  <h2>Reading Wave File Manually</h2>

  <p>Alternately, you can manually call <code>read()</code> to control exactly how much of the file to read. When doing this, make sure to close the <code>Reader</code> when you&rsquo;re done.</p>

  {% highlight ruby %}require "wavefile"
include WaveFile

SAMPLES_PER_BUFFER = 4096

reader = Reader.new("my_file.wav")
begin
  while reader.current_sample_frame < reader.total_sample_frames do
    buffer = reader.read(SAMPLES_PER_BUFFER)
    puts "Read #{buffer.samples.length} sample frames."
  end
rescue EOFError
  puts "Unexpected EOFError before reading all sample frames"
ensure
  reader.close
end{% endhighlight %}
</div>

<div class="section">
  <h2>Reading a Wave File Into an Arbitrary Format</h2>

  <p>When reading sample data you can convert it to a different format on the fly. For example, let&rsquo;s say <code>my_file.wav</code> has 2 channels and 16-bit PCM samples, but you want 1 channel normalized floating point samples. By passing a <code>Format</code> instance to the constructor, the samples will be read out in the desired format regardless of what is actually in the file:</p>
  {% highlight ruby %}require "wavefile"
include WaveFile

# Samples will be read as monophonic floating point,
# regardless of the actual sample format in the file
target_format = Format.new(:mono, :float, 44100)
reader = Reader.new("my_file.wav", target_format).each_buffer do |buffer|
  puts "Read #{buffer.samples.length} sample frames."
end{% endhighlight %}
  <p><strong>Note:</strong> Sample data will not be re-sampled to match the target sample rate. For example, if reading data out of a file with 44,100Hz sample rate using a target <code>Format</code> with a 22,050Hz sample rate, the samples will not be re-sampled to a 22,050Hz sample rate. This means that audio will sound pitch shifted unless the file&rsquo;s actual sample rate and the target sample rate are the same.</p>
</div>

<div class="section bg-white">
  <h2>Getting Metadata About a Wave File</h2>

  <p><code>Reader.format</code> contains info about the format samples will be converted to when being read out of the file, while <code>Reader.native_format</code> contains info about how the samples are actually stored in the file.</p>
  <p><code>Reader.readable_format?</code> will indicate whether the sample data is in a format understood by the WaveFile gem. (If not, an error will be raised when calling <code>Reader.read</code>).</p>
  <p><code>Reader.duration</code> can be used to determine the playback time of the file.</p>

  {% highlight ruby %}require "wavefile"
include WaveFile

file_name = ARGV[0]
puts "Metadata for #{file_name}:"

begin
  reader = Reader.new(file_name)

  puts "  Readable by this gem?  #{reader.readable_format? ? 'Yes' : 'No'}"
  puts "  Audio Format:          #{reader.native_format.audio_format}"
  puts "  Channels:              #{reader.native_format.channels}"
  puts "  Bits per sample:       #{reader.native_format.bits_per_sample}"
  puts "  Samples per second:    #{reader.native_format.sample_rate}"
  puts "  Bytes per second:      #{reader.native_format.byte_rate}"
  puts "  Block align:           #{reader.native_format.block_align}"
  puts "  Sample frame count:    #{reader.total_sample_frames}"

  duration = reader.total_duration
  formatted_duration = duration.hours.to_s.rjust(2, "0") << ":" <<
                       duration.minutes.to_s.rjust(2, "0") << ":" <<
                       duration.seconds.to_s.rjust(2, "0") << ":" <<
                       duration.milliseconds.to_s.rjust(3, "0")
  puts "  Play time:             #{formatted_duration}"
rescue InvalidFormatError
  puts "  Not a valid Wave file!"
end{% endhighlight %}
</div>

<div class="section">
  <h2>Writing a Wave File With A Block</h2>

  <p>The <code>Writer</code> object is used to write data to a wave file. When constructing the <code>Writer</code>, you can pass a block inside which the writing will occur. When the block exits the file will automatically be closed. The example below shows how to write a basic square wave to a file.</p>

  {% highlight ruby %}require "wavefile"
include WaveFile

# Write a 440Hz square wave beep lasting for 1 second
square_cycle = ([0.3] * 50) + ([-0.3] * 50)
buffer = Buffer.new(square_cycle, Format.new(:mono, :float, 44100))
Writer.new("my_file.wav", Format.new(:mono, :pcm_16, 44100)) do |writer|
  441.times { writer.write(buffer) }
end{% endhighlight %}
  <p>This should result in a file named <code>my_file.wav</code> being written to the current directory, and it should sound like this:</p>
  <audio controls>
    <source src="media/square.wav" type="audio/wav">
  </audio>
  <p>For more info on how to create simple sounds with Ruby, check out <a href="https://www.joelstrait.com/nanosynth/">NanoSynth</a>.</p>
</div>

<div class="section bg-white">
  <h2>Writing a Wave File (Manual File Close Edition)</h2>

  <p>Alternately, you can manually control when to close the file, as shown below. Note that a file won&rsquo;t be valid for playback until it is closed. This is because some data required for playback (such as the total number of samples) isn&rsquo;t written to the file until it is closed.</p>

  {% highlight ruby %}require "wavefile"
include WaveFile

writer = Writer.new("my_file.wav", Format.new(:mono, :pcm_16, 44100))

# Write a 440Hz square wave beep lasting for 1 second
square_cycle = ([0.3] * 50) + ([-0.3] * 50)
buffer = Buffer.new(square_cycle, Format.new(:mono, :float, 44100))
441.times do
  writer.write(buffer)
end

# The Wave file isn't in a valid state until this is called
writer.close{% endhighlight %}
  <p>This should result in a file identical to the previous example:</p>
  <audio controls>
    <source src="media/square.wav" type="audio/wav">
  </audio>
</div>

<div class="section">
  <h2>Copying a Wave File to Different Format</h2>

  <p>In this example, the sample data in the file <code>original.wav</code> will be written to <code>copy.wav</code> as stereo/16-bit with a 44,100Hz sample rate, regardless of what format the sample data in <code>original.wav</code> is stored in.</p>

  <p>This example also shows that you can also pass a block to <code>Writer.new()</code>, and the <code>Writer</code> will automatically be closed when the block exits.</p>

  {% highlight ruby %}require "wavefile"
include WaveFile

Writer.new("copy.wav", Format.new(:stereo, :pcm_16, 44100)) do |writer|
  Reader.new("original.wav").each_buffer do |buffer|
    writer.write(buffer)
  end
end{% endhighlight %}
</div>

<div class="section bg-white">
  <h2>Appending Wave Files</h2>

  <p>This example will take 3 Wave files, and write them to a single file containing each input file played one after another. Note that the individual files can be in different formats. They will all be converted to the output file&rsquo;s format.</p>

  {% highlight ruby %}require "wavefile"
include WaveFile

FILES_TO_APPEND = ["file1.wav", "file2.wav", "file3.wav"]

Writer.new("append.wav", Format.new(:stereo, :pcm_16, 44100)) do |writer|
  FILES_TO_APPEND.each do |file_name|
    Reader.new(file_name).each_buffer do |buffer|
      writer.write(buffer)
    end
  end
end{% endhighlight %}
</div>
