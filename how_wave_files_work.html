---
layout: default
title: Wave File Format
---
<div class="section section-tall">
  <h2>Wave File Format</h2>
  <p>The Wave file format has changed over time and is defined in several documents:</p>
  <ul>
    <li><a href="http://www-mmsp.ece.mcgill.ca/Documents/AudioFormats/WAVE/Docs/riffmci.pdf">Multimedia Programming Interface
and Data Specifications 1.0, August 1991</a></li>
    <li><a href="http://www-mmsp.ece.mcgill.ca/Documents/AudioFormats/WAVE/Docs/RIFFNEW.pdf">New Multimedia Data Types and Data Techniques, August 1994</a></li>
    <li><a href="https://msdn.microsoft.com/en-us/library/windows/hardware/dn653308(v=vs.85).aspx">Multiple Channel Audio Data and WAVE Files</a></li>
  </ul>
  <p>This article attempts to consolidate the most important information in one place. This hopefully removes the need to cross-reference multiple documents, weed out extraneous information about other file formats, etc.</p>
  <h2>Getting Started</h2>
  <p>If you&rsquo;re new to audio programming, you might want to read up on some of the basics of digital audio first. Check out <a href="https://www.joelstrait.com/digital_audio_primer/">this blog post</a> for an introduction.</p>

  <h2>Wave Files Store Audio Data</h2>
  <p>Wave files are a container format that allows storing many types of audio data. The most common format is <em>integer PCM</em>. This is raw, uncompressed sample data where each sample is an integer. (<em>PCM</em> stands for <em>pulse code modulation</em>). Similarly, PCM data can be defined using a floating point value for each sample, although this is technically considered a different format.</p>
  <p>There are many other audio formats officially defined. However, most are rare or obsolete.</p>
  <p>Currently, the WaveFile gem supports these sample formats:</p>
  <ul>
    <li>Integer PCM at 8, 16, 24, or 32 bits per sample (format code <code>1</code>)</li>
    <li>Floating point PCM at 32 or 64 bits per sample (format code <code>3</code>)</li>
    <li>The formats above inside a WAVE_FORMAT_EXTENSIBLE container (format code <code>65534</code>)</li>
  </ul>

  <h2>Wave Files are RIFF Files</h2>
  <p>Back in the late 80s Electronic Arts came up with a general container file format that could be used to store different types of data &ndash; audio, graphics, etc. It was called <em>IFF</em>, for <em><a href="https://en.wikipedia.org/wiki/Interchange_File_Format">Interchange File Format</a></em>. Microsoft then took this format, switched the byte order from <a href="https://en.wikipedia.org/wiki/Endianness">big-endian</a> to <a href="https://en.wikipedia.org/wiki/Endianness">little-endian</a> to better suit Intel processors, and dubbed it <em>RIFF (<a href="https://en.wikipedia.org/wiki/Resource_Interchange_File_Format">Resource Interchange File Format</a></em>). The RIFF format was then used for the <code>*.wav</code> file format.</p>
  <p>All multi-byte numbers in a RIFF file are stored as <a href="https://en.wikipedia.org/wiki/Endianness">little-endian</a>. (Some non-numeric data is stored as a sequence of bytes, in which endianness isn&rsquo;t relevant per se).</p>
  <h2>RIFF Files Contain &ldquo;Chunks&rdquo;</h2>
  <p>Like an IFF file, a RIFF file is broken up into &ldquo;chunks&rdquo; of data. Each chunk starts with an 8-byte header containing a 4-byte identifier code, and a 4-byte size field. This is followed by the chunk body.</p>
  <p>The identifier code, called a <a href="https://en.wikipedia.org/wiki/Fourcc">FourCC</a>, is a sequence of 4 bytes. When each byte is interpreted as an 8-bit ASCII character, they typically form a human readable string. For example, <code>0x52</code> <code>0x49</code> <code>0x46</code> <code>0x46</code> (i.e. <code>"RIFF"</code>), or <code>0x64</code> <code>0x61</code> <code>0x74</code> <code>0x61</code> (i.e. <code>"data"</code>). Since this is a raw sequence of bytes, the characters are case-sensitive.</p>
  <p>The size field indicates the size of the chunk&rsquo;s body in bytes, as a 32-bit unsigned integer. The size should not include the 8-byte header. I.e., if a chunk consists of the 8-byte header followed by 1,000 bytes of data, the size field should indicate <code>1000</code>, not <code>1008</code>.</p>
  <p class="important"><span class="tag-important">Important!</span> If a chunk body has an odd number of bytes, it must be followed by a padding byte with value <code>0</code>. In other words, a chunk must always occupy an even number of bytes in the file. The padding byte should <em>not</em> be counted in the chunk header&rsquo;s size field. For example, if a chunk body is 17 bytes in size, the header&rsquo;s size field should be set to <code>17</code>, even though the chunk body occupies 18 bytes (17 bytes of data followed by the padding byte).</p>
  <h2>High Level Wave File Structure</h2>
  <p>At top level, a Wave file consists of a single RIFF chunk (<code>"RIFF"</code>), which contains all of the data for the wave file. The RIFF chunk body starts with the format code <code>"WAVE"</code> which indicates that the file is a Wave file (since a RIFF file can also contain other types of data). This is followed by child chunks, nested inside the parent RIFF chunk.</p>
  <p>At minimum, the child chunks must include a format chunk (<code>"fmt&nbsp;"</code>) and a data chunk (<code>"data"</code>), and the format chunk must come before the data chunk. If the format code in the format chunk is not <code>1</code> (see below), then there must also be a fact chunk (<code>"fact"</code>). Other optional chunk types are also possible.</p>
  <p>A typical file might look like this:</p>
  <div class="chunk-parent">
    <span class="chunk-parent-field">RIFF Chunk ID (<code>"RIFF"</code>)</span>
    <span class="chunk-parent-field">RIFF Chunk Body Size</span>
    <span class="chunk-parent-field">Format Code: <code>"WAVE"</code></span>
    <div class="chunk-child">
      <span class="chunk-child-field">Format Chunk ID (<code>"fmt&nbsp;"</code>)</span>
      <span class="chunk-child-field">Format Chunk Body Size</span>
      <span class="chunk-child-field">Chunk Body<br /><br /><br /></span>
    </div>
    <div class="chunk-child">
      <span class="chunk-child-field">Data Chunk ID (<code>"data"</code>)</span>
      <span class="chunk-child-field">Data Chunk Body Size</span>
      <span class="chunk-child-field">Chunk Body<br /><br /><br /></span>
    </div>
  </div>
  <p class="important"><span class="tag-important">Important!</span> Other than the format chunk coming before the data chunk, there isn&rsquo;t any requirement that the child chunks come in any particular order. You shouldn&rsquo;t assume that the data chunk is the last chunk. (Although in practice, it often is).</p>
  <h2>The RIFF Chunk</h2>
  <p>Like all chunks, the RIFF chunk starts with an FourCC ID code. In this case, it is <code>"RIFF"</code>. Next is the size field, which is the size of the entire Wave file except for the 8-byte RIFF chunk header.</p>
  <p>The first 4 bytes following the header will identify the type of RIFF chunk. In the case of a Wave file, it will be <code>"WAVE"</code>. Immediately following that will be the child chunks.</p>
  <div class="scroll-x">
    <table>
      <tr>
        <th>Field</th>
        <th>Bytes</th>
        <th>Description</th>
      </tr>
      <tr>
        <td>Chunk ID</td>
        <td>4</td>
        <td><code>0x52</code> <code>0x49</code> <code>0x46</code> <code>0x46</code> (i.e. <code>"RIFF"</code>)</td>
      </tr>
      <tr>
        <td>Chunk Body Size</td>
        <td>4</td>
        <td>32-bit unsigned integer</td>
      </tr>
      <tr>
        <td>RIFF Format Code</td>
        <td>4</td>
        <td><code>0x57</code> <code>0x41</code> <code>0x56</code> <code>0x45</code> (i.e. <code>"WAVE"</code>)</td>
      </tr>
      <tr>
        <td>Child Chunks</td>
        <td>Variable</td>
        <td>Variable</td>
      </tr>
    </table>
  </div>

  <h2>The Format Chunk</h2>
  <p>The format chunk describes the format that the samples in the data chunk are encoded in. The exact structure of the format chunk depends on the value of the format code field. If the format code is <code>1</code> (integer PCM), then the format chunk will only contain the fields above the dashed line in the diagram below. If it&rsquo;s not <code>1</code>, the chunk will also contain the fields after the dashed line.</p>
  <div class="scroll-x">
    <table>
      <tr>
        <th>Field</th>
        <th>Bytes</th>
        <th>Description</th>
      </tr>
      <tr>
        <td>Chunk ID</td>
        <td>4</td>
        <td><code>0x66</code> <code>0x6d</code> <code>0x74</code> <code>0x20</code> (i.e. <code>"fmt&nbsp;"</code>)</td>
      </tr>
      <tr>
        <td>Chunk Body Size</td>
        <td>4</td>
        <td>32-bit unsigned integer</td>
      </tr>
      <tr>
        <td>Format Code</td>
        <td>2</td>
        <td>16-bit unsigned integer</td>
      </tr>
      <tr>
        <td>Number of Channels</td>
        <td>2</td>
        <td>16-bit unsigned integer</td>
      </tr>
      <tr>
        <td>Samples per second</td>
        <td>4</td>
        <td>32-bit unsigned integer</td>
      </tr>
      <tr>
        <td>Bytes per Second<br />(a.k.a byte rate)</td>
        <td>4</td>
        <td>32-bit unsigned integer</td>
      </tr>
      <tr>
        <td>Bytes per Sample Frame<br />(a.k.a block align)</td>
        <td>2</td>
        <td>16-bit unsigned integer</td>
      </tr>
      <tr style="border-bottom: 2px #ddd dashed;">
        <td>Bits per sample</td>
        <td>2</td>
        <td>16-bit unsigned integer</td>
      </tr>
      <tr>
        <td colspan="3"><em>These fields are only present if format code is not <code>1</code>:</em></td>
      </tr>
      <tr>
        <td>Extension Size</td>
        <td>2</td>
        <td>16-bit unsigned integer</td>
      </tr>
      <tr>
        <td>Extra fields</td>
        <td>Variable</td>
        <td>It depends on the format code</td>
      </tr>
    </table>
  </div>
  <p class="good-to-know"><span class="tag-good-to-know">Good to Know</span> The reason for the different types of extension is that the Wave format is a container for many different kinds of sample formats, and because the Wave format has evolved over time to support new formats. Extra fields that are needed for one sample format might not be needed for another sample format. This also allows new fields to be added without having to change pre-existing Wave files.</p>
  <p>While some of these fields have a large range of possible values, in practice there are only a few that will actually be used. For some background on what some of this terminology means, check out <a href="https://www.joelstrait.com/digital_audio_primer/">this blog post</a>.</p>
  <p><strong>Format Code</strong> &ndash; Indicates how the sample data for the wave file is stored. The most common format is integer PCM, which has a code of <code>1</code>. Other formats include floating point PCM (<code>3</code>), ADPCM (<code>2</code>), A-law (<code>6</code>), &mu;-law (<code>7</code>), and WaveFormatExtensible (<code>65534</code>).</p>
  <p><strong>Number of channels</strong> &ndash; Typically a file will have 1 channel (mono) or 2 channels (stereo). A 5.1 surround sound file will have 6 channels.</p>
  <p><strong>Sample rate</strong> &ndash; The number of sample frames that occur each second. A typical value would be 44,100, which is the same as an audio CD.</p>
  <p><strong>Bytes per second (a.k.a. byte rate)</strong> &ndash; The spec calls this <em>byte rate</em>, which means the number of bytes required for one second of audio data. This is equal to the bytes per sample frame times the sample rate. So with a bytes per sample frame of 4, and a sample rate of 44,100, this should equal 176,400.</p>
  <p><strong>Bytes per sample frame (a.k.a. block align)</strong> &ndash; Called <em>block align</em> by the spec, this is the number of bytes required to store a single sample frame, i.e. a single sample for each channel. (Sometimes a sample frame is also referred to as a <em>block</em>). Each sample, and the sample frame as a whole, must be a whole number of bytes (i.e. it must be a multiple of 8 bits). For example, a sample frame size of 16 bits is valid, but 12 bits is not.</p>
  <p>To calculate this value, first round bits per sample up to the next multiple of 8 (if necessary), divide by 8, then multiply by the number of channels. For example:</p>
  <div class="scroll-x">
    <table>
      <tr>
        <th>Bits Per Sample</th>
        <th>Channels</th>
        <th>Bytes Per Sample Frame</th>
      </tr>
      <tr>
        <td>5 &rarr; 8</td>
        <td>1</td>
        <td>(8 &div; 8) &times; 1 = 1</td>
      </tr>
      <tr>
        <td>8</td>
        <td>1</td>
        <td>(8 &div; 8) &times; 1 = 1</td>
      </tr>
      <tr>
        <td>8</td>
        <td>2</td>
        <td>(8 &div; 8) &times; 2 = 2</td>
      </tr>
      <tr>
        <td>12 &rarr; 16</td>
        <td>1</td>
        <td>(16 &div; 8) &times; 1 = 2</td>
      </tr>
      <tr>
        <td>16</td>
        <td>1</td>
        <td>(16 &div; 8) &times; 1 = 2</td>
      </tr>
      <tr>
        <td>16</td>
        <td>2</td>
        <td>(16 &div; 8) &times; 2 = 4</td>
      </tr>
      <tr>
        <td>32</td>
        <td>6</td>
        <td>(32 &div; 8) &times; 6 = 24</td>
      </tr>
    </table>
  </div>
  <p>This field can be used to calculate the bytes per second field. Another possible use is for seeking around in a file. For example, if the bytes per sample frame is 4, then to seek forward 10 sample frames you need to seek forward 40 bytes.</p>
  <p><strong>Bits per sample</strong> &ndash; For integer PCM data, typical values will be <code>8</code>, <code>16</code>, or <code>32</code>. If the sample format doesn&rsquo;t require this field, it should be set to <code>0</code>.</p>
  <p><strong>Extension Size</strong> &ndash; This field should only be present if the format code is not <code>1</code>. This indicates the size of the extra fields in bytes. It does not include the bytes in this field itself. If the given sample format has no extra fields, then this field should still be present, but set to <code>0</code>.</p>
  <p><strong>Extra Fields</strong> &ndash; It depends on the format code! The next sections describe the extra fields for a few audio formats.</p>

  <h2>Extra Format Fields for Floating Point</h2>
  <p>If the format code is <code>3</code>, then the sample data is stored as PCM using floating point numbers. There are no extra fields for this format, so the extension size field should be set to <code>0</code>.</p>
  <div class="scroll-x">
    <table>
      <tr>
        <th>Field</th>
        <th>Bytes</th>
        <th>Description</th>
      </tr>
      <tr class="center" style="border-bottom: 2px #ddd dashed;">
        <td colspan="3"><em>&uarr;<br />Other fields in format chunk</em></td>
      </tr>
      <tr>
        <td>Extension Size</td>
        <td>2</td>
        <td>16-bit unsigned integer (value <code>0</code>)</td>
      </tr>
    </table>
  </div>

  <h2>Extra Format Fields for EXTENSIBLE format</h2>
  <p>If the format code is <code>65534</code>, then the format is called &ldquo;WAVE_FORMAT_EXTENSIBLE&rdquo;. This comes from the name of a data structure given to this format in the Windows API. The extensible format is a container format (&hellip;within *.wav, which is itself a container format). It exists to work around some ambiguities in the original Wave file format without having to break compatibility with pre-existing files.</p>
  <p>When the format is WAVE_FORMAT_EXTENSIBLE, the extension size in the format chunk should be <code>22</code>, and the following three fields should be included:</p>
  <div class="scroll-x">
    <table>
      <tr>
        <th>Field</th>
        <th>Bytes</th>
        <th>Description</th>
      </tr>
      <tr class="center" style="border-bottom: 2px #ddd dashed;">
        <td colspan="3"><em>&uarr;<br />Other fields in format chunk</em></td>
      </tr>
      <tr>
        <td>Extension Size</td>
        <td>2</td>
        <td>16-bit unsigned integer (value <code>22</code>)</td>
      </tr>
      <tr>
        <td>Valid Bits Per Sample</td>
        <td>2</td>
        <td>16-bit unsigned integer</td>
      </tr>
      <tr>
        <td>Channel Mask</td>
        <td>4</td>
        <td>32-bit unsigned integer</td>
      </tr>
      <tr>
        <td>Sub Format GUID</td>
        <td>16</td>
        <td>16-byte GUID</td>
      </tr>
    </table>
  </div>
  <p><strong>Valid Bits Per Sample</strong> &ndash; The original Wave file spec is not clear about whether the bits per sample field represents the number of bits in each sample, or the size of the container each sample is in. For example, if each sample is 20 bits inside a 24 bit container, should this field be set to 20, or 24? The spec says this field &ldquo;specifies the number of bits of data used to represent each sample of each channel&rdquo;, which has apparently been interpreted either way.</p>
  <p>In a WAVE_FORMAT_EXTENSIBLE file, this ambiguity is resolved. In this type of file, the bits per sample field should always be set to the container size of one sample, and the valid bits per sample field in the extension should be set to the number of bits that are actually relevant. For example, if a file contains 20 bit samples in 24 bit containers, then the original bits per sample field should be set to 24, and the valid bits per sample field in the extension should be set to 20.</p>
  <p><strong>Channel Mask</strong> &ndash; In a vanilla non-WAVE_FORMAT_EXTENSIBLE file the 1st channel is defined to be mapped to the left speaker, the 2nd channel to the right speaker, but the remaining channel &rarr; speaker mappings are undefined. The channel mask field lets you define specific speaker mappings for each channel (e.g. for a surround sound file with 6 channels). There are 18 defined speakers that can be mapped.</p>
  <p>The least significant 18 bits of this field are used as a bit field to indicate which channel maps to which speaker (if any). Each defined speaker corresponds to a bit:</p>
  <div class="scroll-x">
    <table>
      <tr>
        <th>Bit</th>
        <th>Speaker</th>
      </tr>
      <tr>
        <td>1</td>
        <td>Front Left</td>
      </tr>
      <tr>
        <td>2</td>
        <td>Front Right</td>
      </tr>
      <tr>
        <td>3</td>
        <td>Front Center</td>
      </tr>
      <tr>
        <td>4</td>
        <td>Low Frequency</td>
      </tr>
      <tr>
        <td>5</td>
        <td>Back Left</td>
      </tr>
      <tr>
        <td>6</td>
        <td>Back Right</td>
      </tr>
      <tr>
        <td>7</td>
        <td>Front Left of Center</td>
      </tr>
      <tr>
        <td>8</td>
        <td>Front Right of Center</td>
      </tr>
      <tr>
        <td>9</td>
        <td>Back Center</td>
      </tr>
      <tr>
        <td>10</td>
        <td>Side Left</td>
      </tr>
      <tr>
        <td>11</td>
        <td>Side Right</td>
      </tr>
      <tr>
        <td>12</td>
        <td>Top Center</td>
      </tr>
      <tr>
        <td>13</td>
        <td>Top Front Left</td>
      </tr>
      <tr>
        <td>14</td>
        <td>Top Front Center</td>
      </tr>
      <tr>
        <td>15</td>
        <td>Top Front Right</td>
      </tr>
      <tr>
        <td>16</td>
        <td>Top Back Left</td>
      </tr>
      <tr>
        <td>17</td>
        <td>Top Back Center</td>
      </tr>
      <tr>
        <td>18</td>
        <td>Top Back Right</td>
      </tr>
    </table>
  </div>
  </p>For example, if in a 4-channel file the channels should be mapped (in order) to the front left, front right, side left, and side right speakers, the 4 bytes of the channel mask field should be set to <code>00000011 00000110 00000000 00000000</code>. (Since this is a little endian value, the bytes are ordered from least &rarr; most significant).</p>
  <p>The channels will be mapped in the order of the speakers list above. E.g. if in a 2 channel file the channel mask field has the bits for Back Left and Top Center speakers set, the first channel will be mapped to Back Left and the second channel to Top Center (because Back Left comes earlier than Top Center in the list above).</p>
  <p>If there are more channels than bits set in this field, the remaining channels will have an undefined speaker mapping. If there are more bits set in the speaker mapping than there are channels, the extra bits should be ignored. To explicitly indicate that no channel is mapped to any specific speaker, set this field to <code>0</code>.</p>
  <p>The spec says that if the most significant bit of this field is set to <code>1</code> (e.g. <code>0xFFFFFFFF</code>) it indicates &ldquo;an entity supports all possible channel configurations.&rdquo; To be honest, I don&rsquo;t understand what that means.</p>
  <p><strong>Sub Format GUID</strong> &ndash; Identifies the format of the sample data in the data chunk. Since the format code will already be set to <code>65534</code> to indicate WAVE_FORMAT_EXTENSIBLE, this GUID indicates the sample format instead. Some GUID mappings include:</p>
  <div class="scroll-x">
    <table>
      <tr>
        <th>Format</th>
        <th>Original Format Code</th>
        <th>Extensible GUID</th>
      </tr>
      <tr>
        <td>PCM Integer</td>
        <td><code>1</code></td>
        <td><code>0x0100000000001000800000aa00389b71</code></td>
      </tr>
      <tr>
        <td>ADPCM</td>
        <td><code>2</code></td>
        <td><code>0x0200000000001000800000aa00389b71</code></td>
      </tr>
      <tr>
        <td>PCM Float</td>
        <td><code>3</code></td>
        <td><code>0x0300000000001000800000aa00389b71</code></td>
      </tr>
      <tr>
        <td>A-law</td>
        <td><code>6</code></td>
        <td><code>0x0600000000001000800000aa00389b71</code></td>
      </tr>
      <tr>
        <td>&mu;-law</td>
        <td><code>7</code></td>
        <td><code>0x0700000000001000800000aa00389b71</code></td>
      </tr>
      <tr>
        <td>MPEG</td>
        <td><code>80</code></td>
        <td><code>0x5000000000001000800000aa00389b71</code></td>
      </tr>
    </table>
  </div>

  <h2>The Fact Chunk</h2>
  <div class="scroll-x">
    <table>
      <tr>
        <th>Field</th>
        <th>Bytes</th>
        <th>Description</th>
      </tr>
      <tr>
        <td>Chunk ID</td>
        <td>4</td>
        <td><code>0x66</code> <code>0x61</code> <code>0x63</code> <code>0x74</code> (i.e. <code>"fact"</code>)</td>
      </tr>
      <tr>
        <td>Chunk Body Size</td>
        <td>4</td>
        <td>32-bit unsigned integer</td>
      </tr>
      <tr>
        <td>Number of sample frames</td>
        <td>4</td>
        <td>32-bit unsigned integer</td>
      </tr>
    </table>
  </div>
  <p>The fact chunk indicates how many sample frames are in the file. If the format code is <code>1</code> it&rsquo;s optional; otherwise it&rsquo;s required.</p>
    <p>Note that this field indicates the total number of <em>sample frames</em>, not the total number of samples. For example, if a stereo file contains 1,000 samples for the left channel and 1,000 samples for the right channel, the value of this field should be <code>1000</code>, not <code>2000</code>.</p>
  <p>The reason this chunk exists is that with some sample formats the total number of sample frames can&rsquo;t be determined without reading the entire data chunk (e.g. because they store data in a compressed format that has to be decoded). This gives a way of determining e.g. the playing time for the file without having to do that.</p>
  <p>It&rsquo;s not needed for integer PCM data (format code <code>1</code>), because the total number of sample frames can be derived by dividing the bytes-per-sample-frame field in the format chunk by the total bytes in the data chunk body. For example, if the data chunk body is 352,800 bytes, and bytes-per-sample-frame is 4 (e.g. two 16-bit channels), then the total number of sample frames is 352,800 &div; 4 = 88,200.</p>

  <h2>The Data Chunk</h2>
  <div class="scroll-x">
    <table>
      <tr>
        <th>Field</th>
        <th>Bytes</th>
        <th>Description</th>
      </tr>
      <tr>
        <td>Chunk ID</td>
        <td>4</td>
        <td><code>0x64</code> <code>0x61</code> <code>0x74</code> <code>0x61</code> (i.e. <code>"data"</code>)</td>
      </tr>
      <tr>
        <td>Chunk Body Size</td>
        <td>4</td>
        <td>32-bit unsigned integer</td>
      </tr>
      <tr>
        <td>Sample Data</td>
        <td>Various</td>
        <td>It depends on the format code</td>
      </tr>
    </table>
  </div>
  <p>The layout for the data chunk is simpler than the format chunk: the normal 8-byte chunk header, followed by nothing but raw sample data. The sample data can be stored in a number of formats, which will be indicated by the format code field in the format chunk.</p>
  <p>The following sections describe several formats that sample data in the data chunk can be stored as.</p>

  <h2>Integer PCM Data Chunk</h2>
  <p>Format code: <code>1</code></p>
  <p>This is the most common format, and consists of raw PCM samples as integers. The bits per sample field will indicate the range of the samples:</p>
  <div class="scroll-x">
    <table>
      <tr>
        <th>Bits per sample</th>
        <th>Min Value</th>
        <th>Mid Value</th>
        <th>Max Value</th>
      </tr>
      <tr>
        <td>8</td>
        <td>0</td>
        <td>128</td>
        <td>255</td>
      </tr>
      <tr>
        <td>16</td>
        <td>-32,768</td>
        <td>0</td>
        <td>32,767</td>
      </tr>
      <tr>
        <td>24</td>
        <td>-8,388,608</td>
        <td>0</td>
        <td>8,388,607</td>
      </tr>
      <tr>
        <td>32</td>
        <td>-2,147,483,648</td>
        <td>0</td>
        <td>2,147,483,647</td>
      </tr>
    </table>
  </div>
  <p class="important"><span class="tag-important">Important!</span> Notice that 8-bit samples are unsigned, while larger bit depths are signed.</p>
  <p>Samples in a multi-channel PCM wave file are interleaved. That is, in a stereo file, one sample for the left channel will be followed by one sample for the right channel, followed by another sample for the left channel, then right channel, and so forth.</p>
  <p>One set of interleaved samples is called a <em>sample frame</em> (also called a <em>block</em>). A sample frame will contain one sample for each channel. In a monophonic file, a sample frame will consist of 1 sample. In a stereo file, a sample frame has 2 samples (one for the left channel, one for the right channel). In a 5-channel file, a sample frame has 5 samples. The bytes per sample frame field in the format chunk gives the size in bytes of each sample frame. This can be useful when seeking to a particular sample frame in the file.</p>
  <p>For example, for a 2 channel file with 16-bit PCM samples, the sample data would look like this:</p>
  <div class="flex flex-column flex-row-l flex-align-center flex-justify-center center" style="font-size: 0.8rem;">
    <div style="border: 2px solid #a1a1a1; border-radius: 0.5rem; padding: 0.5rem; margin-right: 0.5rem;">
      Sample Frame 1
      <div>
        <div style="border: 2px solid #a1a1a1; padding: 0.5rem; border-radius: 0.5rem; display: inline-block;">
          Left Channel
          <div>
            <code style="font-size: 0.6rem;">LSB</code>
            <code style="font-size: 0.6rem;">MSB</code>
          </div>
        </div>
        <div style="border: 2px solid #a1a1a1; padding: 0.5rem; border-radius: 0.5rem; display: inline-block;">
          Right Channel
          <div>
            <code style="font-size: 0.6rem;">LSB</code>
            <code style="font-size: 0.6rem;">MSB</code>
          </div>
        </div>
      </div>
    </div>
    <div style="border: 2px solid #a1a1a1; border-radius: 0.5rem; padding: 0.5rem; margin-right: 0.5rem;">
      Sample Frame 2
      <div>
        <div style="border: 2px solid #a1a1a1; padding: 0.5rem; border-radius: 0.5rem; display: inline-block;">
          Left Channel
          <div>
            <code style="font-size: 0.6rem;">LSB</code>
            <code style="font-size: 0.6rem;">MSB</code>
          </div>
        </div>
        <div style="border: 2px solid #a1a1a1; padding: 0.5rem; border-radius: 0.5rem; display: inline-block;">
          Right Channel
          <div>
            <code style="font-size: 0.6rem;">LSB</code>
            <code style="font-size: 0.6rem;">MSB</code>
          </div>
        </div>
      </div>
    </div>
    <div style="padding: 0.5rem;">...etc</div>
  </div>
  <p><code>LSB</code> means &ldquo;least significant byte&rdquo;, and <code>MSB</code> means &ldquo;most significant byte.&rdquo;</p>
  <h2>Floating Point PCM Data Chunk</h2>
  <p>Format code: <code>3</code></p>
  <p>Alternately, PCM samples can be stored as floating point values. This is essentially the same as integer PCM format (i.e. format code <code>1</code>), except that samples are in the range -1.0 to 1.0. The bits per sample field should be set to <code>32</code> or <code>64</code> to indicate the precision of the values. Sample frames should be layed out in the same way as described in the &ldquo;Integer PCM Data Chunk&rdquo; section above.</p>
  <h2>EXTENSIBLE Data Chunk</h2>
  <p>Format code: <code>65534</code></p>
  <p>Since WAVE_FORMAT_EXTENSIBLE is a container format, the format code of <code>65534</code> doesn&rsquo;t imply any particular sample format. Instead, the sample format is indicated by the sub format GUID in the format chunk extension. For example, if the sub format GUID is the GUID for integer PCM, then the samples are in the same format as if the format code was <code>1</code>.</p>

  <h2>References</h2>
  <p>Documents from Microsoft defining the initial file format, and changes over time:</p>
  <ul>
    <li><a href="http://www-mmsp.ece.mcgill.ca/Documents/AudioFormats/WAVE/Docs/riffmci.pdf">Multimedia Programming Interface
and Data Specifications 1.0, August 1991</a></li>
    <li><a href="http://www-mmsp.ece.mcgill.ca/Documents/AudioFormats/WAVE/Docs/RIFFNEW.pdf">New Multimedia Data Types and Data Techniques, August 1994</a></li>
    <li><a href="https://msdn.microsoft.com/en-us/library/windows/hardware/dn653308(v=vs.85).aspx">Multiple Channel Audio Data and WAVE Files</a></li>
  </ul>
  <p>Other links:</p>
  <ul>
    <li><a href="http://www-mmsp.ece.mcgill.ca/Documents/AudioFormats/WAVE/WAVE.html">Helpful summary from McGill University that has similar content as this page</a></li>
    <li><a href="https://en.wikipedia.org/wiki/WAV">Wikipedia article on the *.wav format</a></li>
  </ul>
</div>
