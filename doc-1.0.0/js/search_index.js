var search_data = {"index":{"searchIndex":["wavefile","buffer","bufferconversionerror","duration","format","formaterror","invalidformaterror","reader","readerclosederror","unsupportedformaterror","writer","writerclosederror","==()","bits_per_sample()","channels()","close()","close()","closed?()","closed?()","convert()","convert!()","current_sample_frame()","each_buffer()","format()","mono?()","native_format()","new()","new()","new()","new()","new()","read()","readable_format?()","sample_rate()","stereo?()","total_duration()","total_duration()","total_sample_frames()","write()","readme"],"longSearchIndex":["wavefile","wavefile::buffer","wavefile::bufferconversionerror","wavefile::duration","wavefile::format","wavefile::formaterror","wavefile::invalidformaterror","wavefile::reader","wavefile::readerclosederror","wavefile::unsupportedformaterror","wavefile::writer","wavefile::writerclosederror","wavefile::duration#==()","wavefile::buffer#bits_per_sample()","wavefile::buffer#channels()","wavefile::reader#close()","wavefile::writer#close()","wavefile::reader#closed?()","wavefile::writer#closed?()","wavefile::buffer#convert()","wavefile::buffer#convert!()","wavefile::reader#current_sample_frame()","wavefile::reader#each_buffer()","wavefile::reader#format()","wavefile::format#mono?()","wavefile::reader#native_format()","wavefile::buffer::new()","wavefile::duration::new()","wavefile::format::new()","wavefile::reader::new()","wavefile::writer::new()","wavefile::reader#read()","wavefile::reader#readable_format?()","wavefile::buffer#sample_rate()","wavefile::format#stereo?()","wavefile::reader#total_duration()","wavefile::writer#total_duration()","wavefile::reader#total_sample_frames()","wavefile::writer#write()",""],"info":[["WaveFile","","WaveFile.html","",""],["WaveFile::Buffer","","WaveFile/Buffer.html","","<p>Represents a collection of samples in a certain format (e.g. 16-bit mono).\nReader returns sample data …\n"],["WaveFile::BufferConversionError","","WaveFile/BufferConversionError.html","","<p>Error that is raised when an attempt is made to perform an unsupported or\nundefined conversion between …\n"],["WaveFile::Duration","","WaveFile/Duration.html","","<p>Calculates playback time given the number of sample frames and the sample\nrate. For example, you can …\n"],["WaveFile::Format","","WaveFile/Format.html","","<p>Represents information about the data format for a Wave file, such as\nnumber of channels, bits per sample, …\n"],["WaveFile::FormatError","","WaveFile/FormatError.html","","<p>Error that is raised when a file is not in a format supported by this Gem.\nFor example, because it&#39;s …\n"],["WaveFile::InvalidFormatError","","WaveFile/InvalidFormatError.html","","<p>Error that is raised when constructing a Format instance that is not valid,\ntrying to read from a file …\n"],["WaveFile::Reader","","WaveFile/Reader.html","","<p>Provides the ability to read sample data out of a wave file, as well as\nquery a wave file about its metadata …\n"],["WaveFile::ReaderClosedError","","WaveFile/ReaderClosedError.html","","<p>Error that is raised when trying to read from a Reader instance that has\nbeen closed.\n"],["WaveFile::UnsupportedFormatError","","WaveFile/UnsupportedFormatError.html","","<p>Error that is raised when trying to read from a valid wave file that has\nits sample data stored in a …\n"],["WaveFile::Writer","","WaveFile/Writer.html","","<p>Provides the ability to write data to a wave file.\n<p>When a Writer is constructed it can be given a block. …\n"],["WaveFile::WriterClosedError","","WaveFile/WriterClosedError.html","","<p>Error that is raised when trying to write to a Writer instance that has\nbeen closed.\n"],["==","WaveFile::Duration","WaveFile/Duration.html#method-i-3D-3D","(other_duration)","<p>Returns\n<p>Returns true if this Duration represents that same amount of time as\nother_duration.\n<p>Two Duration …\n"],["bits_per_sample","WaveFile::Buffer","WaveFile/Buffer.html#method-i-bits_per_sample","()","<p>Returns\n<p>Returns the bits per sample of the buffer&#39;s sample data\n"],["channels","WaveFile::Buffer","WaveFile/Buffer.html#method-i-channels","()","<p>Returns\n<p>Returns the number of channels the buffer&#39;s sample data has\n"],["close","WaveFile::Reader","WaveFile/Reader.html#method-i-close","()","<p>Closes the Reader. If the Reader is already closed, does nothing. After a\nReader is closed, no more sample …\n"],["close","WaveFile::Writer","WaveFile/Writer.html#method-i-close","()","<p>Closes the Writer. After a Writer is closed, no more sample data can be\nwritten to it.\n<p>Note that the wave …\n"],["closed?","WaveFile::Reader","WaveFile/Reader.html#method-i-closed-3F","()","<p>Returns\n<p>Returns true if the Reader is closed, and false if it is open and available\nfor reading.\n"],["closed?","WaveFile::Writer","WaveFile/Writer.html#method-i-closed-3F","()","<p>Returns\n<p>Returns true if the Writer is closed, and false if it is open and available\nfor writing.\n"],["convert","WaveFile::Buffer","WaveFile/Buffer.html#method-i-convert","(new_format)","<p>Creates a new Buffer containing the sample data of this Buffer, but\nconverted to a different format. …\n"],["convert!","WaveFile::Buffer","WaveFile/Buffer.html#method-i-convert-21","(new_format)","<p>Converts the sample data contained in the Buffer to a new format. The\nsample data is converted in place, …\n"],["current_sample_frame","WaveFile::Reader","WaveFile/Reader.html#method-i-current_sample_frame","()","<p>Returns\n<p>Returns the index of the sample frame which is “cued up” for reading. I.e.,\nthe index …\n"],["each_buffer","WaveFile::Reader","WaveFile/Reader.html#method-i-each_buffer","(sample_frame_count=4096)","<p>Reads sample data of the into successive Buffers of the specified size,\nuntil there is no more sample …\n"],["format","WaveFile::Reader","WaveFile/Reader.html#method-i-format","()","<p>Returns\n<p>Returns an object describing how sample data is being read from the Wave\nfile. I.e., number of …\n"],["mono?","WaveFile::Format","WaveFile/Format.html#method-i-mono-3F","()","<p>Returns\n<p>Returns true if the format has 1 channel, false otherwise.\n"],["native_format","WaveFile::Reader","WaveFile/Reader.html#method-i-native_format","()","<p>Returns\n<p>Returns an object describing the sample format of the Wave file being read.\nThis returns the data …\n"],["new","WaveFile::Buffer","WaveFile/Buffer.html#method-c-new","(samples, format)","<p>Creates a new Buffer.\n<p>samples &mdash; An array of samples. If the Format has 1 channel (i.e. is mono), this\nshould …\n"],["new","WaveFile::Duration","WaveFile/Duration.html#method-c-new","(sample_frame_count, sample_rate)","<p>Constructs a new immutable Duration.\n<p>sample_frame_count &mdash; The number of sample frames, i.e. the number samples …\n"],["new","WaveFile::Format","WaveFile/Format.html#method-c-new","(channels, format_code, sample_rate, speaker_mapping: nil)","<p>Constructs a new immutable Format.\n<p>channels &mdash; The number of channels in the format. Can either be an Integer …\n"],["new","WaveFile::Reader","WaveFile/Reader.html#method-c-new","(io_or_file_name, format=nil)","<p>Returns\n<p>Returns a Reader object that is ready to start reading the specified\nfile&#39;s sample data.\n<p>io_or_file_name … &mdash; "],["new","WaveFile::Writer","WaveFile/Writer.html#method-c-new","(io_or_file_name, format)","<p>Returns\n<p>Returns a constructed Writer object which is available for writing sample\ndata to the specified …\n"],["read","WaveFile::Reader","WaveFile/Reader.html#method-i-read","(sample_frame_count)","<p>Reads the specified number of sample frames from the wave file into a\nBuffer. Note that the Buffer will …\n"],["readable_format?","WaveFile::Reader","WaveFile/Reader.html#method-i-readable_format-3F","()","<p>Returns\n<p>Returns true if this is a valid Wave file and contains sample data that is\nin a format that this …\n"],["sample_rate","WaveFile::Buffer","WaveFile/Buffer.html#method-i-sample_rate","()","<p>Returns\n<p>Returns the sample rate of the buffer&#39;s sample data\n"],["stereo?","WaveFile::Format","WaveFile/Format.html#method-i-stereo-3F","()","<p>Returns\n<p>Returns true if the format has 2 channels, false otherwise.\n"],["total_duration","WaveFile::Reader","WaveFile/Reader.html#method-i-total_duration","()","<p>Returns\n<p>Returns a Duration instance for the total number of sample frames in the\nfile\n"],["total_duration","WaveFile::Writer","WaveFile/Writer.html#method-i-total_duration","()","<p>Returns\n<p>Returns a Duration instance for the number of sample frames that have been\nwritten so far\n"],["total_sample_frames","WaveFile::Reader","WaveFile/Reader.html#method-i-total_sample_frames","()","<p>Returns\n<p>Returns the total number of sample frames in the file. A sample frame\ncontains a single sample …\n"],["write","WaveFile::Writer","WaveFile/Writer.html#method-i-write","(buffer)","<p>Appends the sample data in the given Buffer to the end of the wave file.\n<p>buffer &mdash; A Buffer instance containing …\n\n"],["README","","README_rdoc.html","","<p>The WaveFile gem lets you read and write wave files.\n<p>Reading is done using the Reader class, and writing …\n"]]}}